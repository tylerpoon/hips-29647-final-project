<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Shaders</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript"
        src="https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js"></script>

    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }

        h1 {
            text-align: center;
        }

        p {
            font-size: 20px;
        }

        .content {
            margin: 20px;
        }
    </style>
</head>

<body>
    <div class="content">
        <h1>Shaders</h1>
        <h2>Introduction</h2>
        <p>
            For this project I chose to investigate shaders, a type of program used to render graphics, often for
            textural or surface effects.
            I chose to investigate shaders because I had seen incredibly detailed graphics on sites like <a
                href="https://www.shadertoy.com/">Shader Toy</a> that seemed to arise magically from very little shader
            code. Since I have no experience in programming shaders, I learned the basics from <a
                href="https://thebookofshaders.com">The Book of Shaders</a> which is an amazing example of teaching
            computer science and math using multimedia. In the process of learning from this book and creating shaders,
            I found that while I
            came to appreciate shaders as examples of visualizing and materializing math (like in the "Inside Out"
            reading),
            my experience creating shaders was distinct from how I've previously engaged with math. Mathematical
            functions became tactile
            and responsive in a way that forced me to develop my intuition for the properties and behavior
            of mathematics and motion. Typically when I see a mathematical visualization I have to reverse-engineer its
            relationship to mathematics through observation,
            whereas while creating shaders I approached this relationship from the opposite direction, starting with a
            mathematical object (e.g. a sine wave, polar coordinates)
            and constructing visuals from the natural projects of that object. This type of exercise was far more useful
            for understanding and getting a feel for mathematics than merely seeing a visual,
            and reinforces that in mathematical learning building a relationship with
            mathematical objects through practice is most effective. While the Tripos method had reams of issues, the
            emphasis on ridiculous amounts of practice
            described at Cambridge in Warwick's book, while much less fun than writing shaders, developed a similar sort
            of relationship between the student and the mathematical objects they worked with. This project gave me some
            hope for the existence of alternatives or at least more fun and compelling forms of practice. Although
            mathematics as play is a common idea
            in modern mathematics pedagogy, this project was one of the rare times where mathematics actually became
            play for me, and gives me hope that mathematics can be made an object of play instead of fear.
        </p>
        <h2>What are shaders?</h2>
        <p>
            Shaders are computer graphics programs, that as described earlier are often used for textures in 3D graphics
            (e.g. rendering a floor tile with a glossy texture),
            although they are incredibly versatile, and as a result are common in the <a
                href="https://en.wikipedia.org/wiki/Demoscene">demoscene</a> for creating computer-rendered art.
            The most common shader language is GLSL (OpenGL Shading Language) which is a C/C++ style language.
            These shaders can be ran on many different platforms, but I'm using WebGL (Web Graphics Library) to run
            these shaders in the browser.
            The type of shaders I made for this project are fragment shaders, which work on a per-pixel level, i.e. they
            give instructions to each individual pixel. Fragment shaders can be thought of as a single program that is
            ran by each pixel individually in parallel,
            where the behavior of each pixel only differs based on its location on the screen. The pixels don't know
            anything
            about the other pixels on the screen, they just execute the shader program in isolation, although they all
            can see some universal values
            like the current time and the location of the mouse. An example of how this type of logic works in practice,
            is if I wanted to draw a red diagonal line with slope 1 across the screen, I write my shader program "if
            your x
            and y coordinates are the same, turn red"
            so when each pixel on this line runs the shader, it will turn red, rendering our line on the screen.
            This model of programming might seem weird at first, but it exploits the parallelism of modern GPUs,
            which have many tiny cores that can execute the shader program for all the pixels in parallel, which is much
            faster than computing the program for each pixel linearly, one at a time.
            GPUs also have special optimizations for certain mathematical functions (e.g. the trigonometric functions) which
            encourages the programmer to use a small toolbox of mathematical functions in clever ways. The specific restrictions
            on shader programming that allow for efficient rendering make it a creative mathematical endeavor.
        </p>
        <canvas class="glslCanvas" data-fragment="
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

#define ITERS 50
#define MIN_A -50.
#define LENGTH_A 100.
#define MIN_B -50.
#define LENGTH_B 100. 

#define PI 3.14159265359

/// COSH Function (Hyperbolic Cosine)
float cosh(float val)
{
    float tmp = exp(val);
    float cosH = (tmp + 1.0 / tmp) / 2.0;
    return cosH;
}
 
// TANH Function (Hyperbolic Tangent)
float tanh(float val)
{
    float tmp = exp(val);
    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);
    return tanH;
}
 
// SINH Function (Hyperbolic Sine)
float sinh(float val)
{
    float tmp = exp(val);
    float sinH = (tmp - 1.0 / tmp) / 2.0;
    return sinH;
}

#define cx_mul(a, b) vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x)
#define cx_div(a, b) vec2(((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y)),((a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y)))
#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))
#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))

vec2 as_polar(vec2 z) {
  return vec2(
    length(z),
    atan(z.y, z.x)
  );
}

vec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }
vec2 cx_log(vec2 a) {
    vec2 polar = as_polar(a);
    float rpart = polar.x;
    float ipart = polar.y;
    if (ipart > PI) ipart=ipart-(2.0*PI);
    return vec2(log(rpart),ipart);
}
vec2 cx_pow(vec2 v, float p) {
  vec2 z = as_polar(v);
  return pow(z.x, p) * vec2(cos(z.y * p), sin(z.y * p));
}

vec2 my_polynomial(vec2 x) {
    return cx_pow(x, 3.) - 6. * cx_pow(x, 2.) + 9. * x - vec2(4., 0.);
}

vec2 my_deriv(vec2 x) {
    return 3. * cx_pow(x, 2.) - 12. * x + vec2(9., 0.);
}

int newton_method(vec2 x0) {
    vec2 current = x0;
    for (int i = 0; i < ITERS; i++) {
        if (distance(current, vec2(1., 0)) < 0.01 || distance(current, vec2(4., 0)) < 0.01) {
            return i;
        }
        current = current - cx_div(my_polynomial(current), my_deriv(current));
    }
    return ITERS;
}

float modI(float a,float b) {
    float m=a-floor((a+0.5)/b)*b;
    return floor(m+0.5);
}

void main() {
    vec2 st = gl_FragCoord.xy/u_resolution;

    float length_a = LENGTH_A / exp(u_time / 5.);
    float min_a = MIN_A + (LENGTH_A - length_a) / 1.886797;
    float length_b = LENGTH_B / exp(u_time / 5.);
    float min_b = MIN_B + (LENGTH_B - length_b) / 2.;

    vec2 x0 = vec2((length_a * st.x) + min_a, (length_b * st.y) + min_b);
    vec3 color = vec3(modI(float(newton_method(x0)), 2.));

    gl_FragColor = vec4(color, 1.0);
}
" width="500" height="500"></canvas>
        <p>Hello testing testing testing</p>
        <canvas class="glslCanvas" data-fragment="
#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 u_resolution;
uniform float u_time;

float plot(vec2 st, float pct){
  return  smoothstep( pct-0.01, pct, st.y) -
          smoothstep( pct, pct+0.01, st.y);
}

//This one needs a lot of work but was good practice
void main() {
    vec2 st = gl_FragCoord.xy/u_resolution;

    float x = (u_time / 10.) + st.x * 3.;
    float y = pow(x, 3.) - 6. * pow(x, 2.) + 11. * x - 6.;
    y = (y + 2. - u_time / 5.) / 3.;

    float pct = plot(st,y);
    float pct_lin = plot(st, ((2. * x - 2.) + 2. - u_time / 5.) / 3.);
    vec3 color = pct*vec3(0.0,1.0,0.0) + pct_lin*vec3(1.0, 0.0, 0.0);

    gl_FragColor = vec4(color,1.0);
}" width="500" height="500"></canvas>
</body>

<canvas class="glslCanvas" data-fragment="
#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 u_resolution;
uniform float u_time;

vec3 color_s = vec3(0.5,0.8,0.9);

float plot (vec2 st, float pct){
  return  smoothstep( pct-0.05, pct, st.y) -
          smoothstep( pct, pct+0.05, st.y);
}

void main() {
    vec2 st = gl_FragCoord.xy/u_resolution;

    vec2 sun_coords = vec2(mod(u_time, PI) / PI, abs(sin(u_time)));

    float d = distance(sun_coords, st) * 2.;
    float pct = 1.0 - smoothstep(0., 0.3, d);

    vec3 color = vec3(0.0);
    color = mix(color, color_s, abs(sin(u_time))); 
    color = mix(color, vec3(0.99,0.72,0.07), pct);
    gl_FragColor = vec4(color, 1.0);
}" width="500" height="500"></canvas>

<canvas class="glslCanvas" data-fragment="
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

void main(){
	vec2 st = gl_FragCoord.xy/u_resolution;
    float pct = 0.0;

    pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));

    float cutoff = abs(sin(u_time)) * 0.8 + 0.1;
	pct = 1. - step(cutoff, pct * 2.);
    vec3 color = vec3(0.9, 0.3, 0.4) * pct;

	gl_FragColor = vec4( color, 1.0 );
}" width="500" height="500"></canvas>

<canvas class="glslCanvas" data-fragment="
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;

#define PI 3.14159265359
#define TWO_PI 2.*PI

float polygon(vec2 st, vec2 offset, int sides) {
    st = st *2.-1. + offset;

    float a = atan(st.x,st.y)+PI;
    float r = TWO_PI/float(sides);
    return cos(floor(.5+a/r)*r-a)*length(st);
}

void main() {
    vec2 st = gl_FragCoord.xy/u_resolution;

    int sides = int(mod(u_time, 10.));

    float oddshape = 1.0 - smoothstep(0.4, 0.41, polygon(st, vec2(-0.4), sides * 2 + 3));
    float evenshape = 1.0 - smoothstep(0.4, 0.41, polygon(st, vec2(0.4), sides * 2 + 4));
    vec3 color = vec3(max(oddshape, evenshape));
    gl_FragColor = vec4(color, 1.0);
}" width="500" height="500"></canvas>

<canvas class="glslCanvas" data-fragment="
#ifdef GL_ES
precision mediump float;
#endif

#define TWO_PI 6.28318530718

uniform vec2 u_resolution;
uniform float u_time;

//  Function from Iñigo Quiles
//  https://www.shadertoy.com/view/MsS3Wc
vec3 hsb2rgb( in vec3 c ){
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                             6.0)-3.0)-1.0,
                     0.0,
                     1.0 );
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * mix( vec3(1.0), rgb, c.y);
}

void main(){
    vec2 st = gl_FragCoord.xy/u_resolution;
    vec3 color = vec3(0.0);

    // Use polar coordinates instead of cartesian
    vec2 toCenter = vec2(0.5)-st;
    float angle = atan(toCenter.y,toCenter.x);
    float radius = length(toCenter)*2.0;
    float time_mod = mod(u_time, 5.) / 5.;

    // Map the angle (-PI to PI) to the Hue (from 0 to 1)
    // and the Saturation to the radius
    color = hsb2rgb(vec3((angle/TWO_PI)+time_mod,radius,1.0));

    gl_FragColor = vec4(color,1.0);
}" width="500" height="500"></canvas>

</html>